//--------------------------------------------------------------------------------------------
//
// Generated by X-HDL VHDL Translator - Version 2.0.0 Feb. 1, 2011
// Tue Mar 1 2022 09:52:41
//
//      Input file      :
//      Component name  : cv_bus_mux
//      Author          :
//      Company         :
//
//      Description     :
//
//
//--------------------------------------------------------------------------------------------

//-----------------------------------------------------------------------------
//
// FPGA Colecovision
//
// $Id: cv_bus_mux.vhd,v 1.3 2006/01/05 22:22:29 arnim Exp $
//
// Bus Multiplexer
//
//-----------------------------------------------------------------------------
//
// Copyright (c) 2006, Arnim Laeuger (arnim.laeuger@gmx.net)
//
// All rights reserved
//
// Redistribution and use in source and synthezised forms, with or without
// modification, are permitted provided that the following conditions are met:
//
// Redistributions of source code must retain the above copyright notice,
// this list of conditions and the following disclaimer.
//
// Redistributions in synthesized form must reproduce the above copyright
// notice, this list of conditions and the following disclaimer in the
// documentation and/or other materials provided with the distribution.
//
// Neither the name of the author nor the names of other contributors may
// be used to endorse or promote products derived from this software without
// specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
// Please report bugs to the author, but before you do so, please
// make sure that this is not a derivative work and that
// you have the latest version of this file.
//
// SystemVerilog conversion (c) 2022 Frank Bruno (fbruno@asicsolutions.com)
//
//-----------------------------------------------------------------------------

module cv_bus_mux
  (
   input              bios_rom_ce_n_i,
   input              ram_ce_n_i,
   input              vdp_r_n_i,
   input              ctrl_r_n_i,
   input              cart_en_80_n_i,
   input              cart_en_a0_n_i,
   input              cart_en_c0_n_i,
   input              cart_en_e0_n_i,
   input              cart_en_sg1000_n_i,
   input              ay_data_rd_n_i,
   input [7:0]        bios_rom_d_i,
   input [7:0]        cpu_ram_d_i,
   input [7:0]        vdp_d_i,
   input [7:0]        ctrl_d_i,
   input [7:0]        cart_d_i,
   input [7:0]        ay_d_i,
   output logic [7:0] d_o
   );


  //---------------------------------------------------------------------------
  // Process mux
  //
  // Purpose:
  //   Masks the data buses and ands them together
  //
  always_comb begin : mux
    logic [7:0]        d_bios_v;
    logic [7:0]        d_ram_v;
    logic [7:0]        d_vdp_v;
    logic [7:0]        d_ctrl_v;
    logic [7:0]        d_cart_v;
    logic [7:0]        d_ay_v;

    // default assignments
    d_bios_v = '1;
    d_ram_v  = '1;
    d_vdp_v  = '1;
    d_ctrl_v = '1;
    d_cart_v = '1;
    d_ay_v   = '1;

    if (~bios_rom_ce_n_i) d_bios_v = bios_rom_d_i;
    if (~ram_ce_n_i)      d_ram_v = cpu_ram_d_i;
    if (~vdp_r_n_i)       d_vdp_v = vdp_d_i;
    if (~ctrl_r_n_i)      d_ctrl_v = ctrl_d_i;
    if (~(cart_en_80_n_i && cart_en_a0_n_i && cart_en_c0_n_i && cart_en_e0_n_i && cart_en_sg1000_n_i))
      d_cart_v = cart_d_i;
    if (~ay_data_rd_n_i)  d_ay_v = ay_d_i;

    d_o = d_bios_v & d_ram_v & d_vdp_v & d_ctrl_v & d_cart_v & d_ay_v;
  end

endmodule
